<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Technical Interview Preparation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        h1 {
            color: #333;
        }
        h2 {
            color: #555;
        }
        pre {
            background-color: #f4f4f4;
            padding: 10px;
            border: 1px solid #ddd;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <h1>Technical Interview Preparation</h1>
    
    <h2>Frontend Fundamentals</h2>
    <h3>Q1: What is the Virtual DOM and how does it improve performance in React?</h3>
    <p><strong>A1:</strong></p>
    <ul>
        <li>The Virtual DOM is an in-memory representation of the real DOM elements.</li>
        <li>React uses it to batch updates and determine the minimal set of changes needed to update the actual DOM.</li>
        <li>This reduces direct manipulation of the DOM, which is slow, leading to improved performance.</li>
    </ul>

    <h3>Q2: How does the CSS Box Model work?</h3>
    <p><strong>A2:</strong></p>
    <ul>
        <li>The CSS Box Model consists of four areas: content, padding, border, and margin.</li>
        <li><strong>Content:</strong> The actual content inside the box.</li>
        <li><strong>Padding:</strong> Space between the content and the border.</li>
        <li><strong>Border:</strong> Surrounds the padding (if any) and content.</li>
        <li><strong>Margin:</strong> Space outside the border, separating the element from others.</li>
    </ul>

    <h3>Q3: Explain the difference between synchronous and asynchronous JavaScript.</h3>
    <p><strong>A3:</strong></p>
    <ul>
        <li><strong>Synchronous:</strong> Code is executed line-by-line; each line must complete before the next starts.</li>
        <li><strong>Asynchronous:</strong> Code can execute without waiting for previous lines to complete, using callbacks, promises, or async/await for handling operations like fetching data.</li>
    </ul>

    <h2>State Management</h2>
    <h3>Q4: How does the Context API differ from Redux?</h3>
    <p><strong>A4:</strong></p>
    <ul>
        <li><strong>Context API:</strong> Built-in React feature for passing data through the component tree without prop drilling. Suitable for simpler state needs.</li>
        <li><strong>Redux:</strong> A more robust, scalable state management solution with a centralized store, supporting complex state logic, middleware, and time-travel debugging.</li>
    </ul>

    <h3>Q5: What are the benefits of using Redux Thunk?</h3>
    <p><strong>A5:</strong></p>
    <ul>
        <li>Redux Thunk allows you to write action creators that return functions instead of plain objects.</li>
        <li>This helps in managing asynchronous operations like API calls within Redux actions, enabling dispatch of multiple actions (e.g., request started, request succeeded/failed).</li>
    </ul>

    <h2>Testing</h2>
    <h3>Q6: What is the difference between unit testing and integration testing?</h3>
    <p><strong>A6:</strong></p>
    <ul>
        <li><strong>Unit Testing:</strong> Tests individual components or functions in isolation to ensure they work as expected.</li>
        <li><strong>Integration Testing:</strong> Tests how different pieces of the system work together, ensuring data flows correctly between modules.</li>
    </ul>

    <h3>Q7: How would you test a React component using Jest and React Testing Library?</h3>
    <p><strong>A7:</strong></p>
    <ul>
        <li>Import the component and necessary libraries.</li>
        <li>Use <code>render()</code> from React Testing Library to render the component.</li>
        <li>Use <code>screen</code> to query elements and <code>fireEvent</code> to simulate user interactions.</li>
        <li>Write assertions with Jestâ€™s <code>expect()</code> to verify the component behaves as expected.</li>
    </ul>

    <h2>CI/CD</h2>
    <h3>Q8: Explain the importance of Continuous Integration (CI) in frontend development.</h3>
    <p><strong>A8:</strong></p>
    <ul>
        <li>CI involves regularly integrating code changes into a shared repository and automatically running tests.</li>
        <li>This ensures early detection of integration issues, reduces bugs, and speeds up the development process.</li>
    </ul>

    <h3>Q9: What steps would you include in a CI pipeline for a React application?</h3>
    <p><strong>A9:</strong></p>
    <ul>
        <li><strong>Code Checkout:</strong> Pull the latest code from the repository.</li>
        <li><strong>Linting:</strong> Run linting tools (e.g., ESLint) to check for code style issues.</li>
        <li><strong>Unit Testing:</strong> Execute unit tests using Jest or similar.</li>
        <li><strong>Build:</strong> Compile the application using Webpack.</li>
        <li><strong>End-to-End Testing:</strong> Run end-to-end tests using Cypress.</li>
        <li><strong>Deployment:</strong> Deploy to a staging environment and eventually to production after approval.</li>
    </ul>

    <h2>Scalability</h2>
    <h3>Q10: How do you ensure a web application can scale effectively?</h3>
    <p><strong>A10:</strong></p>
    <ul>
        <li><strong>Code Splitting:</strong> Load parts of the application as needed.</li>
        <li><strong>Lazy Loading:</strong> Load components or resources only when required.</li>
        <li><strong>Caching:</strong> Use browser caching and service workers to reduce server load.</li>
        <li><strong>Optimized Rendering:</strong> Use techniques like pagination, infinite scrolling, and virtualized lists for large data sets.</li>
    </ul>

    <h3>Q11: How would you handle high traffic in a frontend application?</h3>
    <p><strong>A11:</strong></p>
    <ul>
        <li><strong>CDN:</strong> Use a Content Delivery Network to serve static assets quickly.</li>
        <li><strong>Load Balancing:</strong> Distribute incoming traffic across multiple servers.</li>
        <li><strong>Asynchronous Loading:</strong> Load critical resources first and defer non-critical ones.</li>
    </ul>

    <h2>Coding Practice</h2>
    <h3>Q12: Write a function in JavaScript that debounces a given function.</h3>
    <p><strong>A12:</strong></p>
    <pre><code>function debounce(func, delay) {
  let timer;
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => func.apply(this, args), delay);
  };
}

// Usage
const log = () => console.log('Debounced!');
const debouncedLog = debounce(log, 2000);
debouncedLog(); // Will log 'Debounced!' after 2 seconds if not called again within that time.</code></pre>

    <h3>Q13: Write a simple React component that fetches and displays data from an API.</h3>
    <p><strong>A13:</strong></p>
    <pre><code>import React, { useState, useEffect } from 'react';

function DataFetcher() {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetch('https://api.example.com/data')
      .then(response => response.json())
      .then(data => {
        setData(data);
        setLoading(false);
      })
      .catch(error => console.error('Error fetching data:', error));
  }, []);

  if (loading) {
    return <p>Loading...</p>;
  }

  return (
    <div>
      <h1>Data</h1>
      <pre>{JSON.stringify(data, null, 2)}</pre>
    </div>
  );
}

export default DataFetcher;</code></pre>

<h3>Q16: What is the difference between Controlled and Uncontrolled components in React?</h3>
    <p><strong>A16:</strong></p>
    <ul>
        <li><strong>Controlled Components:</strong> Components where the form data is handled by the React component's state. The state is updated via event handlers.</li>
        <li><strong>Uncontrolled Components:</strong> Components where the form data is handled by the DOM itself. You access the data using refs.</li>
    </ul>

    <h3>Q17: How does the Event Loop work in JavaScript?</h3>
    <p><strong>A17:</strong></p>
    <ul>
        <li>The Event Loop is a mechanism that manages the execution of asynchronous code in JavaScript.</li>
        <li>It continuously checks the call stack and the task queue, executing the tasks in the queue only when the call stack is empty.</li>
        <li>Asynchronous operations (e.g., setTimeout, Promises) are handled via the Event Loop, allowing non-blocking execution.</li>
    </ul>

    <h3>Q18: What is a Higher-Order Component (HOC) in React?</h3>
    <p><strong>A18:</strong></p>
    <ul>
        <li>A Higher-Order Component (HOC) is a function that takes a component and returns a new component with additional props or behaviors.</li>
        <li>HOCs are used for reusing component logic, such as authentication checks or data fetching.</li>
        <li>Example usage: <code>const EnhancedComponent = withHoc(WrappedComponent);</code></li>
    </ul>

</body>
</html>
